}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=2)
plot(model)
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
model2=kmeans(X,centers=3,nstart=10)
df <- read_excel("ex4.2.xls")
X <- df[,2:5] # 要聚类的变量
X <- scale(X, center=TRUE, scale=TRUE)#按列规范化，均值为0，方差为1
d <- dist(X, method="euclidean", diag=F, upper=F)
heatmap(as.matrix(d),labRow = F, labCol = F) # 热力图
center_total <- colMeans(X)
TSS <- sum((scale(X, center = center_total, scale = FALSE))^2)
k_max <- 15
wss <- numeric(k_max)
diff <- 0
idx <- 1
for (k in 1:k_max) {
km <- kmeans(X, centers = k, nstart = 25, iter.max = 100)
wss[k] <- km$tot.withinss / TSS # 计算组内离差平方和/总离差平方和
if(k > 2){
diff_cur <- wss[k-1] - wss[k]
# 找变化最剧烈的拐点
if(diff_cur > diff){
diff <- diff_cur
idx <- k
}
}
}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=3)
plot(model)
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
model2=kmeans(X,centers=3,nstart=10)
df <- read_excel("ex4.2.xls")
X <- df[,2:5] # 要聚类的变量
X <- scale(X, center=TRUE, scale=TRUE)#按列规范化，均值为0，方差为1
d <- dist(X, method="euclidean", diag=F, upper=F)
cat("绘制热力图，颜色越深代表样本间越接近")
heatmap(as.matrix(d),labRow = F, labCol = F) # 热力图
center_total <- colMeans(X)
TSS <- sum((scale(X, center = center_total, scale = FALSE))^2)  #总离差平方和
k_max <- 15
wss <- numeric(k_max)
diff <- 0
idx <- 1
for (k in 1:k_max) {
km <- kmeans(X, centers = k, nstart = 25, iter.max = 100)
wss[k] <- km$tot.withinss / TSS # 计算组内离差平方和/总离差平方和
if(k > 2){
diff_cur <- wss[k-1] - wss[k]
# 找变化最剧烈的拐点
if(diff_cur > diff){
diff <- diff_cur
idx <- k
}
}
}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=3)
cat("谱系聚类图：")
plot(model)
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
model2=kmeans(X,centers=3,nstart=10)
df <- read_excel("ex4.2.xls")
X <- df[,2:5] # 要聚类的变量
X <- scale(X, center=TRUE, scale=TRUE)#按列规范化，均值为0，方差为1
d <- dist(X, method="euclidean", diag=F, upper=F)
heatmap(as.matrix(d),labRow = F, labCol = F) # 热力图
center_total <- colMeans(X)
TSS <- sum((scale(X, center = center_total, scale = FALSE))^2)  #总离差平方和
k_max <- 15
wss <- numeric(k_max)
diff <- 0
idx <- 1
for (k in 1:k_max) {
km <- kmeans(X, centers = k, nstart = 25, iter.max = 100)
wss[k] <- km$tot.withinss / TSS # 计算组内离差平方和/总离差平方和
if(k > 2){
diff_cur <- wss[k-1] - wss[k]
# 找变化最剧烈的拐点
if(diff_cur > diff){
diff <- diff_cur
idx <- k
}
}
}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=3)
plot(model,main = "谱系聚类图")
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
model2=kmeans(X,centers=3,nstart=10)
print(model2)
suppressWarnings({df <- read_excel("ex4.2.xls")})
X <- df[,2:5] # 要聚类的变量
X <- scale(X, center=TRUE, scale=TRUE)#按列规范化，均值为0，方差为1
d <- dist(X, method="euclidean", diag=F, upper=F)
heatmap(as.matrix(d),labRow = F, labCol = F) # 热力图
center_total <- colMeans(X)
TSS <- sum((scale(X, center = center_total, scale = FALSE))^2)  #总离差平方和
k_max <- 15
wss <- numeric(k_max)
diff <- 0
idx <- 1
for (k in 1:k_max) {
km <- kmeans(X, centers = k, nstart = 25, iter.max = 100)
wss[k] <- km$tot.withinss / TSS # 计算组内离差平方和/总离差平方和
if(k > 2){
diff_cur <- wss[k-1] - wss[k]
# 找变化最剧烈的拐点
if(diff_cur > diff){
diff <- diff_cur
idx <- k
}
}
}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=3)
plot(model,main = "谱系聚类图")
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
# 用kmeans聚类
model2=kmeans(X,centers=3,nstart=10)
print(model2)
df <- read_excel("ex4.2.xls")
X <- df[,2:5] # 要聚类的变量
X <- scale(X, center=TRUE, scale=TRUE)#按列规范化，均值为0，方差为1
d <- dist(X, method="euclidean", diag=F, upper=F)
heatmap(as.matrix(d),labRow = F, labCol = F) # 热力图
center_total <- colMeans(X)
TSS <- sum((scale(X, center = center_total, scale = FALSE))^2)  #总离差平方和
k_max <- 15
wss <- numeric(k_max)
diff <- 0
idx <- 1
for (k in 1:k_max) {
km <- kmeans(X, centers = k, nstart = 25, iter.max = 100)
wss[k] <- km$tot.withinss / TSS # 计算组内离差平方和/总离差平方和
if(k > 2){
diff_cur <- wss[k-1] - wss[k]
# 找变化最剧烈的拐点
if(diff_cur > diff){
diff <- diff_cur
idx <- k
}
}
}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=3)
plot(model,main = "谱系聚类图")
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
# 用kmeans聚类
model2=kmeans(X,centers=3,nstart=10)
print(model2)
df <- read_excel("ex4.2.xls")
X <- df[,2:5] # 要聚类的变量
X <- scale(X, center=TRUE, scale=TRUE)#按列规范化，均值为0，方差为1
d <- dist(X, method="euclidean", diag=F, upper=F)
heatmap(as.matrix(d),labRow = F, labCol = F) # 热力图
center_total <- colMeans(X)
TSS <- sum((scale(X, center = center_total, scale = FALSE))^2)  #总离差平方和
k_max <- 15
wss <- numeric(k_max)
diff <- 0
idx <- 1
for (k in 1:k_max) {
km <- kmeans(X, centers = k, nstart = 25, iter.max = 100)
wss[k] <- km$tot.withinss / TSS # 计算组内离差平方和/总离差平方和
if(k > 2){
diff_cur <- wss[k-1] - wss[k]
# 找变化最剧烈的拐点
if(diff_cur > diff){
diff <- diff_cur
idx <- k
}
}
}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=3)
plot(model,main = "谱系聚类图")
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
# 用kmeans聚类
cat("用k-means方法聚类：")
model2=kmeans(X,centers=3,nstart=10)
print(model2)
df <- read_excel("ex4.2.xls")
X <- df[,2:5] # 要聚类的变量
X <- scale(X, center=TRUE, scale=TRUE)#按列规范化，均值为0，方差为1
d <- dist(X, method="euclidean", diag=F, upper=F)
heatmap(as.matrix(d),labRow = F, labCol = F) # 热力图
center_total <- colMeans(X)
TSS <- sum((scale(X, center = center_total, scale = FALSE))^2)  #总离差平方和
k_max <- 15
wss <- numeric(k_max)
diff <- 0
idx <- 1
for (k in 1:k_max) {
km <- kmeans(X, centers = k, nstart = 25, iter.max = 100)
wss[k] <- km$tot.withinss / TSS # 计算组内离差平方和/总离差平方和
if(k > 2){
diff_cur <- wss[k-1] - wss[k]
# 找变化最剧烈的拐点
if(diff_cur > diff){
diff <- diff_cur
idx <- k
}
}
}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=3)
plot(model,main = "谱系聚类图")
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
# 用kmeans聚类
cat("用k-means方法聚类：")
model2=kmeans(X,centers=3,nstart=10)
print(model2$cluster)
df <- read_excel("ex4.2.xls")
X <- df[,2:5] # 要聚类的变量
clust <- function(X,rows,num_k)
{
X <- scale(X, center=TRUE, scale=TRUE)#按列规范化，均值为0，方差为1
d <- dist(X, method="euclidean", diag=F, upper=F)
heatmap(as.matrix(d),labRow = F, labCol = F) # 热力图
center_total <- colMeans(X)
TSS <- sum((scale(X, center = center_total, scale = FALSE))^2)  #总离差平方和
k_max <- rows-1
wss <- numeric(k_max)
diff <- 0
idx <- 1
for (k in 1:k_max) {
km <- kmeans(X, centers = k, nstart = 25, iter.max = 100)
wss[k] <- km$tot.withinss / TSS # 计算组内离差平方和/总离差平方和
if(k > 2){
diff_cur <- wss[k-1] - wss[k]
# 找变化最剧烈的拐点
if(diff_cur > diff){
diff <- diff_cur
idx <- k
}
}
}
cat("组内离差平方和/总离差平方和：")
print(wss)
cat("拐点的索引：")
print(idx)
# 绘制碎石图
plot(1:k_max, wss,
type = "b", pch = 19, col = "blue",
xlab = "聚类数量 k",
ylab = "WSS / TSS",
main = "组内离差平方和占比曲线")
model <- hclust(d,method = "ward.D2")
result=cutree(model,k=num_k)
plot(model,main = "谱系聚类图")
mds=cmdscale(d,k=2,eig=T)
x = mds$points[,1]
y = mds$points[,2]
df_p <- data.frame(
x = mds$points[, 1],
y = mds$points[, 2],
cluster = factor(result)
)
p <- ggplot(df_p, aes(x = x, y = y, color = cluster)) +
geom_point(size = 3, alpha = 0.8) +
scale_color_manual(
values = c("#E41A1C", "#377EB8", "#4DAF4A"),
name = "Cluster"
) +
theme_minimal()
print(p)
# 用kmeans聚类
cat("用k-means方法聚类：")
model2=kmeans(X,centers=num_k,nstart=10)
print(model2$cluster)
}
clust(X,16,3)
df2 <- read_excel("ex4.3.xls")
X2 <- df2[,2:6] # 要聚类的变量
clust(X2,31,3)
str(X2)
df2 <- read_excel("ex4.3.xls")
X2 <- df2[,2:6] # 要聚类的变量
new_names <- X2[1, ] %>% as.character()
data_rows <- X2[-1, ]
colnames(data_rows) <- new_names
X2 <- data_rows %>%
mutate(across(everything(), ~ parse_number(.x)))
#clust(X2,31,3)
str(X2)
df2 <- read_excel("ex4.3.xls")
X2 <- df2[,2:6] # 要聚类的变量
names <- X2[1, ] %>% as.character()
data <- X2[-1, ]
colnames(data) <- names
X2 <- data %>%
mutate(across(everything(), ~ parse_number(.x)))
clust(X2,31,3)
df2 <- read_excel("ex4.3.xls")
X2 <- df2[,2:6] # 要聚类的变量
names <- X2[1, ] %>% as.character()
data <- X2[-1, ]
colnames(data) <- names
X2 <- data %>%
mutate(across(everything(), ~ parse_number(.x)))
clust(X2,31,2)
df2 <- read_excel("ex4.3.xls")
X2 <- df2[,2:6] # 要聚类的变量
names <- X2[1, ] %>% as.character()
data <- X2[-1, ]
colnames(data) <- names
X2 <- data %>%
mutate(across(everything(), ~ parse_number(.x)))
clust(X2,31,3)
